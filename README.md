# Elmer

Describe the behavior of Elm HTML applications.

### Example

Let's test-drive a simple Elm HTML Application. We want to have a button on the screen that, when clicked, updates a counter. First, we write a test, using [Elm-Test](https://github.com/elm-community/elm-test) and Elmer:

```
allTests : Test
allTests =
  let
    initialState = Elmer.componentState App.defaultModel App.view App.update
  in
    describe "my app"
    [ describe "initial state"
      [ test "it shows that no clicks have occurred" <|
        \() ->
          Elmer.find "#clickCount"
            |> Elmer.expectNode (
                \node ->
                  Matchers.hasText "0 clicks!" node
            )      
      ]
    ]
```

Our test finds the html element containing the counter text by its id and checks that it has the text we expect when the app first appears. Let's make it pass:

```
type alias Model =
  { clicks: Int }

defaultModel : Model
defaultModel =
  { clicks = 0 }

type Msg =
  NothingYet

view : Model -> Html Msg
view model =
  div [ id "clickCount" ] [ text "0 clicks!") ]

update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  ( model, Cmd.None )
```

If we run our test now, it should pass.

Now, let's add a new test that describes what we expect to happen when a button is clicked.

```
  describe "when the button is clicked"
  [ test "it updates the counter" <|
    \() ->
      Elmer.find ".button" initialState
        |> Event.click
        |> Event.click
        |> Elmer.find "#clickCount"
        |> Elmer.expectNode (
          \node ->
            Matchers.hasText "2 clicks!" node
        )
  ]
```

This should fail, since we don't even have a button in our view yet. Let's fix that. We'll add a button with a click event handler that sends a message we can handle in the update function. We update the `Msg` type, the `view` function, and the `update` function like so:

```
type Msg =
  HandleClick

view : Model -> Html Msg
view model =
  div []
    [ div [ id "clickCount" ] [ text ((toString model.clicks) ++ " clicks!") ]
    , div [ class "button", onClick HandleClick ] [ text "Click Me" ]  
    ]

update : Msg -> Model -> (Model, Cmd Msg)
update msg model =
  case msg of
    HandleClick ->
      ( { model | clicks = model.clicks + 1 }, Cmd.None )
```

And our test should pass.

Notice that we were able to test-drive our app, writing our tests first, without worrying about implementation details like the names of the messages our `update` function will use and so on. Elmer simulates the elm architecture workflow, delivering messages to the `update` function when events occur and passing the result to the `view` function so you can write expectations about the updated html. Elmer exposes an `HtmlNode` record and matchers that make it easy to write expectations about the html generated by the `view` function.

Elmer makes it easy to practice behavior-driven development with Elm.

### Tasks

Often the `update` function will result in a command to perform some `Task`. Elmer provides support for executing simple tasks generated by the `Task.succeed` or `Task.fail` functions. Of course, your app will probably need to execute more complicated tasks, such as HTTP requests. To make your app easy to test, you'll want to structure your model such that it contains the functions that generate such tasks. Then, in your test, you can provide a model that replaces these functions with either `Task.succeed` or `Task.fail` to describe the behavior for each case.
