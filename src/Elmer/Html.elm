module Elmer.Html exposing
  ( HtmlTarget
  , HtmlElement
  , HtmlSelector
  , HtmlSelectorGroup
  , target
  , expect
  , render
  )

{-| Functions for working with the `Html msg` generated by the component's view function.

# Target Html Elements
@docs HtmlTarget, HtmlElement, HtmlSelector, HtmlSelectorGroup, target

# Make Expectations
@docs expect

# Render the View
@docs render

-}

import Elmer exposing (Matcher)
import Elmer.TestState as TestState exposing (TestState)
import Elmer.Context as Context exposing (Context)
import Elmer.Runtime.Command as RuntimeCommand
import Elmer.Html.Types exposing (HtmlState(..))
import Elmer.Html.Target as Target
import Elmer.Errors as Errors exposing (failWith)
import Html exposing (Html)
import Expect


{-| Represents an Html element.
-}
type alias HtmlElement msg
  = Elmer.Html.Types.HtmlElement msg


{-| Represents the Html Element or Elements about which expectations will be made.

An `HtmlTarget` is determined by the last use of `Elmer.Html.target`.
-}
type alias HtmlTarget msg
  = Elmer.Html.Types.HtmlTarget msg


{-| Represents a function for matching an Html Element.

You can create your own `HtmlSelector`. For example, here's 
an `HtmlSelector` that matches any element that has at least one
of the given classes:

    oneOfClasses : List String -> HtmlSelector msg
    oneOfClasses expectedClasses element =
      { description = "one of " ++ String.join "," expectedClasses
      , predicate = \element ->
          Element.classList element
            |> List.filter (\c -> List.member c expectedClasses)
            |> not << List.isEmpty
      }

which you could use to target elements that have either the class `funny` or `awesome`
like so:

    target << by [ oneOfClasses [ "funny", "awesome" ] ]
-}
type alias HtmlSelector msg =
  { description : String
  , predicate : HtmlElement msg -> Bool
  }


{-| Represents a group of `HtmlSelector` used to match an Html Element.
-}
type alias HtmlSelectorGroup msg =
  Elmer.Html.Types.HtmlSelectorGroup msg


{-| Target an element or elements within the Html produced by the
component's `view` function.

Use this function to specify which element will receive an event or which should
be the subject of any expectations.

See `Elmer.Html.Selector` for some common selectors. For example, to target
a `div` that has a class `.some-class` and is a child of a `li` whose ancestor is an
element with `root` as the value of its `id` attribute:

    target 
      << descendantsOf [ id "root" ]
      << childrenOf [ tag "li" ]
      << by [ tag "div", class ".some-class" ]

You can chain as many `Elmer.Html.Selector.descendantsOf` or `Elmer.Html.Selector.childrenOf` calls
as you like; the chain must end with a call to `Elmer.Html.Selector.by`.
-}
target : (HtmlSelectorGroup msg, Elmer.TestState model msg) -> Elmer.TestState model msg
target (selector, testState) =
  TestState.map (\context ->
    RuntimeCommand.mapState TargetSelector (\_ -> selector)
      |> Context.updateStateFor context
      |> TestState.with
  ) testState


{-| Make expectations about the targeted html.

    testState
      |> target << by [ class "my-class" ]
      |> expect (
        Elmer.Html.Matchers.element <|
          Elmer.Html.Matchers.hasText "some text"
      )

Use `expect` in conjunction with matchers like `element`, `elementExists`,
or `elements`.
-}
expect : Matcher (HtmlTarget msg) -> Matcher (Elmer.TestState model msg)
expect matcher =
  TestState.mapToExpectation <|
    \context ->
      case Context.state TargetSelector context of
        Just selector ->
          case Context.render context of
            Just view ->
              matcher <| Target.forHtml selector view
            Nothing ->
              failWith Errors.noModel
        Nothing ->
          Expect.fail "No expectations could be made because no Html has been targeted.\n\nUse Elmer.Html.target to identify the Html you want to describe."


{-| Call the component's view function with the current model.

Sometimes, it may be useful to render the component's view manually. For example,
if you are spying on some function called by the view function, you'll need to
render the view manually before you can make expectations about that spy.

Note: Usually you will not need to render the view manually.
-}
render : Elmer.TestState model msg -> Elmer.TestState model msg
render =
  TestState.map <|
    \context ->
      let
        view = Context.render context
      in
        TestState.with context
