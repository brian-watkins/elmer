module Elmer.Html.Matchers exposing
  ( element
  , elements
  , elementExists
  , hasText
  , hasClass
  , hasAttribute
  , hasId
  , hasStyle
  , listensForEvent
  )

{-| Make expectations about the Html generated by a view function.

# HtmlTarget Matchers
@docs element, elementExists, elements

# HtmlElement Matchers
@docs hasText, hasId, hasClass, hasStyle, hasAttribute, listensForEvent

-}

import Elmer exposing (Matcher)
import Elmer.Internal exposing (..)
import Elmer.Html.Types exposing (..)
import Elmer.Html
import Elmer.Html.Element.Internal as Html_
import Elmer.Html.Query as Query
import Elmer.Errors as Errors exposing (failWith)
import Elmer.Message exposing (..)
import Expect
import String
import Json.Decode as Json
import Dict exposing (Dict)
import Html as Html exposing (Html)


{-| Make expectations about the selected element.

The matcher will fail if the selected element does not exist.

If the selector matches more than one element,
the given element matcher will only be applied to the first element selected.

    testState
      |> Elmer.Html.target 
          << by [ tag "div" ]
      |> Elmer.Html.expect (
          element <| hasText "Fun Stuff"
        )

-}
element : Matcher (Elmer.Html.HtmlElement msg) -> Matcher (Elmer.Html.HtmlTarget msg)
element elementMatcher =
  \query ->
    case Query.findElement query of
      Ok foundElement ->
        elementMatcher foundElement
      Err msg ->
        Expect.fail msg

{-| Expect that the selected element exists.

    testState
      |> Elmer.Html.target 
          << by [ id "cool-element" ]
      |> Elmer.Html.expect elementExists
-}
elementExists : Matcher (Elmer.Html.HtmlTarget msg)
elementExists =
  \query ->
    case Query.findElement query of
      Ok _ ->
        Expect.pass
      Err msg ->
        Expect.fail msg


{-| Make expectations about the selected elements.

If the selector fails to match any elements, an empty list will
be passed to the given matcher.

    testState
      |> Elmer.Html.target 
          << by [ tag "li" ]
      |> Elmer.Html.expect (
          elements <| Elmer.hasLength 4
        )
-}
elements : Matcher (List (Elmer.Html.HtmlElement msg)) -> Matcher (Elmer.Html.HtmlTarget msg)
elements listMatcher =
  \query ->
    Query.findElements query
      |> listMatcher


{-| Expect that an element has some text. This matcher will pass only if the element
or any of its descendents contains some `Html.text` with the specified text.
-}
hasText : String -> Matcher (Elmer.Html.HtmlElement msg)
hasText text =
  \node ->
    let
        texts =
            flattenTexts node.children
    in
        if List.length texts == 0 then
            Expect.fail (format [ fact "Expected element to have text" text, note "but it has no text" ])
        else if List.member text texts then
            Expect.pass
        else
            Expect.fail (format [ fact "Expected element to have text" text, fact "but it has" (printList texts) ])

{-| Expect that an element has the specified class. No need to prepend the class name with a dot.
-}
hasClass : String -> Matcher (Elmer.Html.HtmlElement msg)
hasClass className =
  \node ->
    let
        classList =
            Html_.classList node
    in
        if List.length classList > 0 then
            if List.member className classList then
                Expect.pass
            else
                Expect.fail (format [fact "Expected element to have class" className, fact "but it has" (printList classList) ])
        else
            Expect.fail (format [fact "Expected element to have class" className, note "but it has no classes" ])


{-| Expect that an element has the specified attribute or property with the specified value.

    testState
      |> Elmer.Html.target
          << by [ id "fun-element" ]
      |> Elmer.Html.expect (element <|
          hasAttribute ( "src", "http://fun.com" )
        )

On the difference between attributes and properties,
see [this](https://github.com/elm-lang/html/blob/master/properties-vs-attributes.md).
-}
hasAttribute : (String, String) -> Matcher (Elmer.Html.HtmlElement msg)
hasAttribute (expectedName, expectedValue) =
  \node ->
    let
      allAttrs = Html_.allAttrs node
    in
      case Dict.get expectedName allAttrs of
        Just actualValue ->
          if expectedValue == actualValue then
            Expect.pass
          else
            failWith <| Errors.wrongAttribute expectedName expectedValue actualValue
        Nothing ->
          if Dict.isEmpty allAttrs then
            failWith <| Errors.noAttribute expectedName expectedValue
          else
            failWith <| Errors.wrongAttributeName expectedName expectedValue allAttrs


{-| Expect that an element has the specified id. No need to prepend the id with a pound sign.
-}
hasId : String -> Matcher (Elmer.Html.HtmlElement msg)
hasId expectedId =
  \node ->
    case Html_.elementId node of
      Just nodeId ->
        if nodeId == expectedId then
          Expect.pass
        else
          Expect.fail (format [fact "Expected element to have id" expectedId, fact "but it has id" nodeId ])
      Nothing ->
        Expect.fail (format [fact "Expected element to have id" expectedId, note "but it has no id" ])

{-| Expect that an element has the specified style.

    hasStyle ("left", "20px") element

-}
hasStyle : (String, String) -> Matcher (Elmer.Html.HtmlElement msg)
hasStyle (name, value) =
  \targeted ->
    let
      styleDict = Html_.styles targeted
    in
      if Dict.isEmpty styleDict then
        Expect.fail <| format
            [ fact "Expected element to have style" <| name ++ ": " ++ value
            , note "but it has no style"
            ]
      else
          case Dict.get name styleDict of
            Just styleValue ->
              if styleValue == value then
                Expect.pass
              else
                Expect.fail <| format
                  [ fact "Expected element to have style" <| name ++ ": " ++ value
                  , fact "but it has style" (printDict styleDict)
                  ]
            Nothing ->
              Expect.fail <| format
                [ fact "Expected element to have style" <| name ++ ": " ++ value
                , fact "but it has style" (printDict styleDict)
                ]
      

{-| Expect that an element listens for an event of the given type.

    testState
      |> Elmer.Html.target
          << by [ id "fun-element" ]
      |> Elmer.Html.expect (element <|
          listensForEvent "click"
        )

Note: This will not consider event handlers on the element's ancestors.
-}
listensForEvent : String -> Matcher (Elmer.Html.HtmlElement msg)
listensForEvent event =
  \targeted ->
    if List.isEmpty targeted.eventHandlers then
      Expect.fail <| format
        [ fact "Expected element to listen for event" event
        , note "but it has no event listeners"
        ]
    else
      if List.any (\eventHandler -> eventHandler.eventType == event) targeted.eventHandlers then
        Expect.pass
      else
        Expect.fail <| format
          [ fact "Expected element to listen for event" event
          , fact "but it listens for" <| (
            List.map .eventType targeted.eventHandlers
              |> String.join "\n"
            )
          ]


-- Private functions

flattenTexts : List (HtmlNode msg) -> List String
flattenTexts children =
    List.concat <|
        List.map
            (\child ->
                case child of
                    Element n ->
                        flattenTexts n.children

                    Text t ->
                        [ t ]
            )
            children


printList : List String -> String
printList list =
    String.join ", " list

printDict : Dict String String -> String
printDict dict =
  Dict.toList dict
    |> List.map (\(name, value) -> name ++ ": " ++ value)
    |> String.join "\n"
