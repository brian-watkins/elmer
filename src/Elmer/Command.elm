module Elmer.Command exposing
  ( fail
  , stub
  , defer
  , resolveDeferred
  , dummy
  , expectDummy
  , send
  , use
  , override
  , batchOverride
  )

{-| Functions for dealing with commands during your tests.

Elmer allows you to manage the effects of commands yourself, so you can
describe the behavior of a component under whatever conditions you need.

To manage the effects of a command, you'll need to do two things.

1. Override the function in your code that produces the command and replace
it with a function that returns one of the fake commands described below.

2. Enjoy.

Note: Elmer supports `Platform.Cmd.batch` and `Platform.Cmd.map` so you can use these in your
component as expected.

Note: Elmer provides special support for commands generated by
[elm-lang/http](http://package.elm-lang.org/packages/elm-lang/http/latest)
and [elm-lang/navigation](http://package.elm-lang.org/packages/elm-lang/navigation/latest/Navigation)
-- See `Elmer.Http` and `Elmer.Navigation`, respectively.

# Fake Commands
@docs stub, dummy, expectDummy, fail

# Override a Command
@docs override, batchOverride, use

# Defer a Command
@docs defer, resolveDeferred

# Send a Fake Command
@docs send

-}

import Elmer exposing (Matcher)
import Elmer.Internal as Internal exposing (..)
import Elmer.Runtime as Runtime
import Elmer.Printer exposing (..)
import Elmer.Platform as Platform exposing (PlatformOverride)
import Elmer.Command.Internal as InternalCommand
import Expect

{-| Combine a List of PlatformOverrides into a single override.
-}
batchOverride : List PlatformOverride -> PlatformOverride
batchOverride overrides =
  Platform.batchOverride overrides

{-| Override a function that generates a command.

The first argument is a function that simply returns the function you want to
override. The second argument is a function with the same signature as the function
to override. It should return one of the fake commands described above, so that
Elmer will know what to do.

Note: This function merely creates a description of the override; the function
is not actually overridden until you call `Command.use`.

You could override `Task.perform` with a stubbed command that tags some data like so:

    override (\_ -> Task.perform) (\tagger task ->
      stub (tagger "some data")
    )

-}
override : (() -> a) -> (b -> c) -> PlatformOverride
override namingFunc overridingFunc =
  Platform.override namingFunc overridingFunc

{-| Use command overrides during a segment of your test.

Suppose your component contains a button that,
when clicked, issues a command to get the current date and updates the view. To
get the current date, in your code you'll need to create a `Task` with `Date.now` and then
generate a command with `Task.perform`. To describe this behavior in your test
, you could do something like the following:

    let
      taskOverride = override (\_ -> Task.perform) (\tagger task ->
        stub (tagger (toDate "11/12/2016 5:30 pm"))
      )
    in
      componentState
        |> find "#get-date"
        |> use [ taskOverride ] click
        |> find "#current-date"
        |> expectElement (hasText "11/12/2016 5:30 pm")

-}
use : List PlatformOverride -> (ComponentState model msg -> ComponentState model msg) -> ComponentState model msg -> ComponentState model msg
use overrides mapper =
  Platform.mapWithOverrides "commands" overrides (\componentState ->
    Ready componentState
      |> mapper
  )

{-| Generate a command that will cause the test to fail with the specified message.
-}
fail : String -> Cmd msg
fail message =
  Platform.toCmd "Elmer_Fail" message

{-| Generate a command that returns a message.

When this command is processed, the message will be passed
to the component's `update` function.
-}
stub : msg -> Cmd msg
stub message =
  Platform.toCmd "Elmer_Stub" message

{-| Generate a dummy command.

You might only care to describe the fact that a command has been sent, and not
the behavior that may result from its effect. In that case, use a dummy command.

When this command is processed, the fact that it occured will be
recorded; no message will be passed to the component's `update` function.
This will be most useful in conjunction with `expectDummy`.
-}
dummy : String -> Cmd msg
dummy identifier =
  InternalCommand.mapState <|
    updateComponentStateWithDummyCommand identifier

updateComponentStateWithDummyCommand : String -> Component model msg -> Component model msg
updateComponentStateWithDummyCommand identifier componentState =
  { componentState | dummyCommands = identifier :: componentState.dummyCommands }

{-| Expect that a dummy command with the given identifier has been sent.
-}
expectDummy : String -> Matcher (ComponentState model msg)
expectDummy expectedIdentifier =
  Internal.mapToExpectation (\componentState ->
    let
      dummyCommands = List.filter (\identifier -> identifier == expectedIdentifier) componentState.dummyCommands
    in
      if List.isEmpty dummyCommands then
        Expect.fail (format [message "No dummy commands sent with identifier" expectedIdentifier])
      else
        Expect.pass
  )

{-| Defer a command for later processing.

You might want to describe the behavior that occurs after a command
in sent but before its effect is processed -- for example, the component could
indicate that network activity is occurring while waiting for a request to complete.

When a deferred command is processed, any effect associated with that command will *not* be sent
to he component's `update` function until `resolveDeferred` is called.
-}
defer : Cmd msg -> Cmd msg
defer command =
  InternalCommand.mapState <|
    updateComponentStateWithDeferredCommand command

updateComponentStateWithDeferredCommand : Cmd msg -> Component model msg -> Component model msg
updateComponentStateWithDeferredCommand command componentState =
  { componentState | deferredCommands = command :: componentState.deferredCommands }

{-| Resolve any deferred commands.

Once this function is called, all messages associated with deferred commands will be
sent to the component's `update` function.
-}
resolveDeferred : ComponentState model msg -> ComponentState model msg
resolveDeferred =
  Internal.map (\componentState ->
    if List.isEmpty componentState.deferredCommands then
      Failed "No deferred commands found"
    else
      let
        deferredCommands = Cmd.batch componentState.deferredCommands
        updatedComponentState = { componentState | deferredCommands = [] }
      in
        Runtime.performCommand deferredCommands updatedComponentState
          |> asComponentState
  )

{-| Send a command.

Use this function to send a command to your component. Any effect associated with this
command will be processed accordingly. Elmer only knows how to process the fake commands
described above.
-}
send : Cmd msg -> ComponentState model msg -> ComponentState model msg
send command =
    Internal.map (\state ->
      Runtime.performCommand command state
        |> asComponentState
    )


asComponentState : Result String (Component model msg) -> ComponentState model msg
asComponentState commandResult =
  case commandResult of
    Ok updatedComponentState ->
      Ready updatedComponentState
    Err message ->
      Failed message
